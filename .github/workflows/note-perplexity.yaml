name: Note Workflow (SEO URL -> note)

on:
  workflow_dispatch:
    inputs:
      seo_url:
        description: '投稿元のSEO記事URL'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  fetch:
    name: Fetch SEO article (Extract title/body)
    runs-on: ubuntu-latest
    env:
      SEO_URL: ${{ github.event.inputs.seo_url }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      final_b64: ${{ steps.collect.outputs.final_b64 }}
      title: ${{ steps.collect.outputs.title }}
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm init -y
          npm i jsdom @mozilla/readability

      - name: Extract article
        run: |
          cat > fetch.mjs <<'EOF'
          import { JSDOM } from 'jsdom';
          import { Readability } from '@mozilla/readability';
          import fs from 'fs';

          function normalizeUrl(raw) {
            const s = String(raw || '').trim();
            if (!s) return '';
            const half = s.replace(/？/g, '?').replace(/＃/g, '#').replace(/＆/g, '&');
            const encoded = encodeURI(half);
            return new URL(encoded).toString();
          }

          const raw = process.env.SEO_URL || '';
          const url = normalizeUrl(raw);
          if (!url) {
            console.error('SEO_URL is empty');
            process.exit(1);
          }

          const res = await fetch(url, {
            redirect: 'follow',
            headers: {
              'User-Agent':
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
              'Accept': 'text/html,application/xhtml+xml'
            }
          });

          const finalUrl = res.url; // ★これが超重要（redirect後のURL）
          console.log('DEBUG_FETCH_FINAL_URL=', finalUrl)

          if (!res.ok) {
            console.error('fetch failed:', res.status, res.statusText);
            process.exit(1);
          }

          const html = await res.text();

          const dom = new JSDOM(html, { url: finalUrl });
          const reader = new Readability(dom.window.document);
          const article = reader.parse();

          if (!article || !article.content) {
            console.error('Readability failed to extract content');
            process.exit(1);
          }

          const inputTags = (process.env.INPUT_TAGS || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);

          const attributionHtml =
            `<p><strong>出典</strong>: <a href="${finalUrl}" rel="nofollow noopener" target="_blank">${finalUrl}</a></p><hr/>`;

          const out = {
            title: (article.title || '').trim() || '（タイトル取得失敗）',
            body_html: attributionHtml + article.content,
            tags: inputTags,
            source_url: url
          };

          fs.writeFileSync('final.json', JSON.stringify(out, null, 2));
          console.log('Extracted:', out.title);
          EOF
          node fetch.mjs

      - name: Verify extracted files
        run: |
          ls -la
          test -f final.json && echo "final.json exists" || (echo "final.json missing" && exit 1)

      - name: Upload extracted artifact
        uses: actions/upload-artifact@v4
        with:
          name: extracted-article
          if-no-files-found: error
          path: |
            final.json



      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('final.json','utf8')).title)")
          b64=$(base64 -w 0 final.json 2>/dev/null || base64 final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  post:
    name: Post to note.com (Playwright)
    needs: fetch
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_B64: ${{ secrets.NOTE_STORAGE_STATE_B64 }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_B64" || (echo "ERROR: NOTE_STORAGE_STATE_B64 secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_B64" | base64 -d > "$RUNNER_TEMP/note-state.json"
          node -e "JSON.parse(require('fs').readFileSync('$RUNNER_TEMP/note-state.json','utf8')); console.log('storageState JSON OK')"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.fetch.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
          
        run: |
          : > post.log
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';
        
          function nowStr() {
            const d = new Date();
            const z = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${z(d.getMonth() + 1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`;
          }
        
          function sanitizeTitle(t) {
            let s = String(t || '').trim();
            s = s.replace(/^#+\s*/, '');
            s = s.replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');
            if (!s) s = 'タイトル（自動生成）';
            return s;
          }
        
          // HTMLを「本文として安全に入るテキスト」に変換（最小限）
          function htmlToText(html) {
            let s = String(html || '');
            // br / p / li / hr を改行に寄せる
            s = s.replace(/<\s*br\s*\/?\s*>/gi, '\n');
            s = s.replace(/<\s*\/p\s*>/gi, '\n\n');
            s = s.replace(/<\s*p(\s+[^>]*)?>/gi, '');
            s = s.replace(/<\s*\/li\s*>/gi, '\n');
            s = s.replace(/<\s*li(\s+[^>]*)?>/gi, '・');
            s = s.replace(/<\s*hr\s*\/?\s*>/gi, '\n\n---\n\n');
        
            // aタグは「テキスト (URL)」にする（軽い）
            s = s.replace(/<a [^>]*href="([^"]+)"[^>]*>(.*?)<\/a>/gi, (_, href, text) => {
              const t = String(text || '').replace(/<[^>]+>/g, '').trim();
              const u = String(href || '').trim();
              if (!t) return u;
              return `${t} (${u})`;
            });
        
            // それ以外のタグを落とす
            s = s.replace(/<[^>]+>/g, '');
        
            // HTMLエンティティ軽く戻す
            s = s
              .replace(/&nbsp;/g, ' ')
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&quot;/g, '"')
              .replace(/&#39;/g, "'");
        
            // 連続空白/改行を整形
            s = s.replace(/\r/g, '');
            s = s.replace(/[ \t]+\n/g, '\n');
            s = s.replace(/\n{3,}/g, '\n\n');
            return s.trim() + '\n';
          }
        
          async function typeLargeText(page, text) {
            // ProseMirrorに大量投入すると落ちることがあるので分割
            const chunk = 800;
            for (let i = 0; i < text.length; i += chunk) {
              const part = text.slice(i, i + chunk);
              await page.keyboard.insertText(part);
              // 少しだけ譲る（429/不安定対策）
              if (i % (chunk * 20) === 0) await page.waitForTimeout(50);
            }
          }
        
          async function main() {
            const STATE_PATH = process.env.STATE_PATH;
            const START_URL = process.env.START_URL || 'https://editor.note.com/new';
            const rawTitle = process.env.TITLE || '';
            const TAGS = process.env.TAGS || '';
            const IS_PUBLIC = String(process.env.IS_PUBLIC || 'false') === 'true';
        
            if (!STATE_PATH || !fs.existsSync(STATE_PATH)) {
              console.error('storageState not found:', STATE_PATH);
              process.exit(1);
            }
        
            const rawFinal = JSON.parse(fs.readFileSync('final.json', 'utf8'));
            const rawBodyHtml = String(rawFinal.body_html || '');
            if (!rawBodyHtml.trim()) {
              console.error('body_html is empty in final.json');
              process.exit(1);
            }
        
            const TITLE = sanitizeTitle(rawTitle);
            const BODY_TEXT = htmlToText(rawBodyHtml);
            console.log('DEBUG_BODY_TEXT_LEN=', BODY_TEXT.length);
            console.log('DEBUG_BODY_TEXT_HEAD=', BODY_TEXT.slice(0, 200));

        
            const ssDir = path.join(os.tmpdir(), 'note-screenshots');
            fs.mkdirSync(ssDir, { recursive: true });
            const SS_PATH = path.join(ssDir, `note-post-${nowStr()}.png`);
        
            let browser, context, page;
        
            try {
              browser = await chromium.launch({
                headless: true,
                args: [
                  '--lang=ja-JP',
                  '--disable-blink-features=AutomationControlled',
                  '--no-sandbox',
                ],
              });
        
              context = await browser.newContext({
                storageState: STATE_PATH,
                locale: 'ja-JP',
                viewport: { width: 1365, height: 900 },
                userAgent:
                  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
              });
        
              await context.addInitScript(() => {
                Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
              });
        
              await context.tracing.start({ screenshots: true, snapshots: true, sources: true });
        
              page = await context.newPage();
              page.setDefaultTimeout(180000);
        
              page.on('console', msg => console.log('BROWSER_CONSOLE:', msg.type(), msg.text()));
              page.on('pageerror', err => console.log('BROWSER_PAGEERROR:', err.message));
              page.on('requestfailed', req => console.log('REQ_FAILED:', req.url(), req.failure()?.errorText));
        
              const rawState = fs.readFileSync(STATE_PATH, 'utf8');
              console.log('DEBUG_STATE_BYTES=', rawState.length);
        
              const cookies0 = await context.cookies();
              const noteCookies0 = cookies0.filter(c => (c.domain || '').includes('note.com'));
              console.log('DEBUG_NOTE_COOKIE_COUNT(before goto)=', noteCookies0.length);
              console.log('DEBUG_NOTE_COOKIE_NAMES(before goto)=', noteCookies0.map(c => c.name).slice(0, 30).join(','));
        
              // 認証確認（200が返るならログインは通ってる）
              const resp = await context.request.get('https://note.com/api/v2/current_user');
              console.log('DEBUG_current_user_status=', resp.status());
              const txt = await resp.text();
              console.log('DEBUG_current_user_body_head=', txt.slice(0, 200));
        
              await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
              await page.waitForTimeout(3000);
        
              console.log('DEBUG_URL_AFTER_GOTO=' + page.url());
        
              // /new から /notes/.../edit へ遷移するのを待つ
              const urlNow = page.url();
              const isEditUrl = /\/notes\/[^/]+\/edit\/?/i.test(urlNow);
              if (!isEditUrl) {
                await page.waitForURL(/\/notes\/[^/]+\/edit\/?/i, { timeout: 60000 }).catch(() => {});
              }
              console.log('DEBUG_URL_AFTER_WAIT_EDIT=' + page.url());
        
              await page.screenshot({ path: SS_PATH, fullPage: true });
              console.log('SCREENSHOT=' + SS_PATH);
        
              // ===== 本文エディタ(ProseMirror)を特定 =====
              const bodyCandidates = [
                // data-testid 系（noteが持ってることが多い）
                '[data-testid*="editor" i] .ProseMirror[contenteditable="true"]',
                '[data-testid*="body" i] .ProseMirror[contenteditable="true"]',
              
                // よくある構造
                'main .ProseMirror[contenteditable="true"]',
                'article .ProseMirror[contenteditable="true"]',
              
                // 最終手段：ProseMirror複数なら「2つ目以降」を本文とみなす
                '.ProseMirror[contenteditable="true"]',
              ];
              
              let bodyBox = null;
              
              // 1) セレクタ候補を上から試す
              for (const sel of bodyCandidates) {
                const loc = page.locator(sel);
                const n = await loc.count().catch(() => 0);
                if (n === 0) continue;
              
                // selが広すぎる場合を考慮して「画面内で大きい要素」を本文とみなす
                let best = null;
                let bestArea = 0;
                for (let i = 0; i < n; i++) {
                  const el = loc.nth(i);
                  if (!(await el.isVisible().catch(() => false))) continue;
                  const box = await el.boundingBox().catch(() => null);
                  if (!box) continue;
                  const area = box.width * box.height;
                  if (area > bestArea) {
                    bestArea = area;
                    best = el;
                  }
                }
                if (best) { bodyBox = best; break; }
              }
              
              if (!bodyBox) {
                fs.writeFileSync('debug-body.html', await page.content());
                await page.screenshot({ path: 'debug-body.png', fullPage: true });
                throw new Error('Body editor not found');
              }
              
              await bodyBox.waitFor({ state: 'visible', timeout: 60000 });
              console.log('DEBUG_BODY_BOX_FOUND=', await bodyBox.evaluate(el => el.className));

        
              // ===== タイトルを特定（あなたのスクショでは本文とは別要素）=====
              const titleCandidates = [
                // input/textarea 系
                'input[placeholder*="タイトル"]',
                'textarea[placeholder*="タイトル"]',
                'input[name*="title" i]',
                'textarea[name*="title" i]',
        
                // aria
                'input[aria-label*="タイトル"]',
                'textarea[aria-label*="タイトル"]',
        
                // data-testid 系（noteが変えても拾いやすい）
                '[data-testid*="title" i] input',
                '[data-testid*="title" i] textarea',
                '[data-testid*="title" i]',
        
                // 最終手段：画面上部の見出しっぽい入力
                'input[type="text"]',
              ];
        
              let titleEl = null;
              for (const sel of titleCandidates) {
                const loc = page.locator(sel).first();
                if (await loc.isVisible().catch(() => false)) { titleEl = loc; break; }
              }
        
              if (!titleEl) {
                fs.writeFileSync('debug-title.html', await page.content());
                await page.screenshot({ path: 'debug-title.png', fullPage: true });
                throw new Error('Title element not found (candidates exhausted)');
              }
        
              const titleTag = await titleEl.evaluate(el => el.tagName.toLowerCase());
              if (titleTag === 'input' || titleTag === 'textarea') {
                await titleEl.fill(TITLE);
              } else {
                await titleEl.click({ force: true });
                await page.keyboard.press('Control+A');
                await page.keyboard.type(TITLE, { delay: 5 });
              }
        
              // ===== 本文入力（HTMLではなくテキストで入れる：最重要）=====
              await bodyBox.click({ force: true });
              await page.keyboard.press('Control+A');
              await page.keyboard.press('Backspace');
        
              // ProseMirrorは insertHTML が不安定なので insertText で流し込む
              // ===== 本文入力 =====
              await bodyBox.click({ force: true });
              
              // 全消し
              await page.keyboard.press('Control+A');
              await page.keyboard.press('Backspace');
              
              // execCommand(insertText)で分割投入（ProseMirrorが拾いやすい）
              async function insertByExecCommand(text) {
                const chunk = 800;
                for (let i = 0; i < text.length; i += chunk) {
                  const part = text.slice(i, i + chunk);
              
                  await page.evaluate((t) => {
                    // activeElement に対して insertText
                    document.execCommand('insertText', false, t);
                  }, part);
              
                  if (i % (chunk * 20) === 0) await page.waitForTimeout(50);
                }
              }
              
              // フォーカスを強制（念のため）
              await bodyBox.evaluate(el => el.focus());
              
              await insertByExecCommand(BODY_TEXT);
              
              await page.waitForTimeout(1500);
        
              if (!IS_PUBLIC) {
                // 下書き保存（ボタンが見えない場合があるので複数候補）
                const saveBtn = page.locator('button:has-text("下書き保存"), button:has-text("下書きを保存"), [aria-label*="下書き保存"]').first();
                if (await saveBtn.count()) {
                  await saveBtn.click({ force: true }).catch(() => {});
                }
                await page.waitForTimeout(2000);
        
                await page.screenshot({ path: SS_PATH, fullPage: true });
                console.log('DRAFT_URL=' + page.url());
                console.log('SCREENSHOT=' + SS_PATH);
                return; // main() 内なので合法
              }

              const bodyTextNow = await bodyBox.evaluate(el => el.innerText || '');
              console.log('DEBUG_BODY_AFTER_LEN=', bodyTextNow.trim().length);
              if (bodyTextNow.trim().length < 20) {
                await page.screenshot({ path: 'debug-body-after.png', fullPage: true });
                throw new Error('Body seems not inserted (too short). Check selectors.');
              }

        
              // ===== 公開フロー（必要なら後で調整）=====
              const proceed = page.locator('button:has-text("公開に進む")').first();
              await proceed.waitFor({ state: 'visible' });
              await proceed.click({ force: true });
        
              await Promise.race([
                page.waitForURL(/\/publish/i).catch(() => {}),
                page.locator('button:has-text("投稿する")').first().waitFor({ state: 'visible' }).catch(() => {})
              ]);
        
              const tags = (TAGS || '').split(/[\n,]/).map(s => s.trim()).filter(Boolean);
              if (tags.length) {
                let tagInput = page.locator('input[placeholder*="ハッシュタグ"]');
                if (!(await tagInput.count())) tagInput = page.locator('input[role="combobox"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const t of tags) {
                  await tagInput.click();
                  await tagInput.fill(t);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(120);
                }
              }
        
              const publishBtn = page.locator('button:has-text("投稿する")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click({ force: true });
        
              await page.waitForTimeout(5000);
              await page.screenshot({ path: SS_PATH, fullPage: true });
        
              console.log('PUBLISHED_URL=' + page.url());
              console.log('SCREENSHOT=' + SS_PATH);
            } finally {
              try { await context?.tracing?.stop({ path: 'trace.zip' }); } catch {}
              try { await page?.close(); } catch {}
              try { await context?.close(); } catch {}
              try { await browser?.close(); } catch {}
            }
          }
        
          // ここで実行（returnもOK）
          main().catch(e => {
            console.error(e);
            process.exit(1);
          });
          EOF
        
          node post.mjs 2>&1 | tee -a post.log
        
          mkdir -p note-screenshots || true
          cp -r /tmp/note-screenshots/* note-screenshots/ 2>/dev/null || true
        
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
        
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi
