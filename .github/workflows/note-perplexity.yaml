name: Note Workflow (SEO URL -> note)

on:
  workflow_dispatch:
    inputs:
      seo_url:
        description: '投稿元のSEO記事URL'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  fetch:
    name: Fetch SEO article (Extract title/body)
    runs-on: ubuntu-latest
    env:
      SEO_URL: ${{ github.event.inputs.seo_url }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      final_b64: ${{ steps.collect.outputs.final_b64 }}
      title: ${{ steps.collect.outputs.title }}
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm init -y
          npm i jsdom @mozilla/readability

      - name: Extract article
        run: |
          cat > fetch.mjs <<'EOF'
          import { JSDOM } from 'jsdom';
          import { Readability } from '@mozilla/readability';
          import fs from 'fs';
          
          function normalizeUrl(raw) {
            const s = String(raw || '').trim();
            if (!s) return '';
            // 全角記号を半角へ
            const half = s.replace(/？/g, '?').replace(/＃/g, '#').replace(/＆/g, '&');
            // URL全体を安全にエンコード
            const encoded = encodeURI(half);
            return new URL(encoded).toString();
          }
          
          const raw = process.env.SEO_URL || '';
          const url = normalizeUrl(raw);
          if (!url) {
            console.error('SEO_URL is empty');
            process.exit(1);
          }
          
          const res = await fetch(url, {
            redirect: 'follow',
            headers: {
              'User-Agent':
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
              'Accept': 'text/html,application/xhtml+xml'
            }
          });
          
          if (!res.ok) {
            console.error('fetch failed:', res.status, res.statusText);
            process.exit(1);
          }
          
          const html = await res.text();
          
          const dom = new JSDOM(html, { url });
          const reader = new Readability(dom.window.document);
          const article = reader.parse();
          
          if (!article || !article.content) {
            console.error('Readability failed to extract content');
            process.exit(1);
          }
          
          const inputTags = (process.env.INPUT_TAGS || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          
          // 出典表記を先頭に付ける（任意だが推奨）
          const attributionHtml =
            `<p><strong>出典</strong>: <a href="${url}" rel="nofollow noopener" target="_blank">${url}</a></p><hr/>`;
          
          const out = {
            title: (article.title || '').trim() || '（タイトル取得失敗）',
            body_html: attributionHtml + article.content,
            tags: inputTags,
            source_url: url
          };
          
          fs.writeFileSync('final.json', JSON.stringify(out, null, 2));
          console.log('Extracted:', out.title);
          EOF
          node fetch.mjs

      - name: Upload extracted artifact
        uses: actions/upload-artifact@v4
        with:
          name: extracted-article
          path: final.json

      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('final.json','utf8')).title)")
          b64=$(base64 -w 0 final.json 2>/dev/null || base64 final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  post:
    name: Post to note.com (Playwright)
    needs: fetch
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_B64: ${{ secrets.NOTE_STORAGE_STATE_B64 }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright
          npx playwright install --with-deps chromium | cat
          
      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_B64" || (echo "ERROR: NOTE_STORAGE_STATE_B64 secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_B64" | base64 -d > "$RUNNER_TEMP/note-state.json"
          node -e "JSON.parse(require('fs').readFileSync('$RUNNER_TEMP/note-state.json','utf8')); console.log('storageState JSON OK')"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.fetch.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr() {
            const d = new Date();
            const z = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${z(d.getMonth() + 1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`;
          }

          const STATE_PATH = process.env.STATE_PATH;
          const START_URL = process.env.START_URL || 'https://editor.note.com/new';
          const rawTitle = process.env.TITLE || '';
          const rawFinal = JSON.parse(fs.readFileSync('final.json', 'utf8'));
          const rawBodyHtml = String(rawFinal.body_html || '');
          const TAGS = process.env.TAGS || '';
          const IS_PUBLIC = String(process.env.IS_PUBLIC || 'false') === 'true';

          if (!fs.existsSync(STATE_PATH)) {
            console.error('storageState not found:', STATE_PATH);
            process.exit(1);
          }
          if (!rawBodyHtml.trim()) {
            console.error('body_html is empty in final.json');
            process.exit(1);
          }

          const ssDir = path.join(os.tmpdir(), 'note-screenshots');
          fs.mkdirSync(ssDir, { recursive: true });
          const SS_PATH = path.join(ssDir, `note-post-${nowStr()}.png`);

          function sanitizeTitle(t) {
            let s = String(t || '').trim();
            s = s.replace(/^#+\s*/, '');
            s = s.replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');
            if (!s) s = 'タイトル（自動生成）';
            return s;
          }

          async function insertHTML(page, locator, html) {
            await locator.click();
            await locator.evaluate((el, html) => {
              el.focus();
              const sel = window.getSelection();
              const range = document.createRange();
              range.selectNodeContents(el);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
              document.execCommand('insertHTML', false, html);
            }, html);
          }

          let TITLE = sanitizeTitle(rawTitle);

          let browser, context, page;
          try {
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            await context.tracing.start({ screenshots: true, snapshots: true, sources: true });
            page.on('console', msg => console.log('BROWSER_CONSOLE:', msg.type(), msg.text()));
            page.on('pageerror', err => console.log('BROWSER_PAGEERROR:', err.message));
            page.on('requestfailed', req => console.log('REQ_FAILED:', req.url(), req.failure()?.errorText));
            
            page.on('response', res => {
              const status = res.status();
              const url = res.url();
              if (status >= 400 && /note\.com/.test(url)) {
                console.log('HTTP_ERROR:', status, url);
              }
            });

            page.setDefaultTimeout(180000);
            const rawState = fs.readFileSync(STATE_PATH, 'utf8');
            console.log('DEBUG_STATE_BYTES=', rawState.length);
            
            const cookies0 = await context.cookies();
            const noteCookies0 = cookies0.filter(c => (c.domain || '').includes('note.com'));
            console.log('DEBUG_NOTE_COOKIE_COUNT(before goto)=', noteCookies0.length);
            console.log('DEBUG_NOTE_COOKIE_NAMES(before goto)=', noteCookies0.map(c => c.name).slice(0, 30).join(','));
            
            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            // “描画された”判定に使える候補（note側のUI変化に備えて複数）
            const editorReadySelectors = [
              '[contenteditable="true"][data-placeholder*="記事タイトル"]',
              '[contenteditable="true"][data-placeholder*="タイトル"]',
              // もしヘッダーやメニューがあるならそれも
              'text=下書き', // 例（実際に出る文言に合わせて）
            ];
            
            const loginOrBlockSelectors = [
              'text=ログイン',
              'text=メールアドレス',
              'text=パスワード',
              'text=アクセスが制限されています',
            ];
            
            await Promise.race([
              page.waitForSelector(editorReadySelectors.join(','), { timeout: 60000 }),
              page.waitForSelector(loginOrBlockSelectors.join(','), { timeout: 60000 }),
            ]).catch(() => {});
            console.log('DEBUG_URL_AFTER_GOTO=' + page.url());
            await page.screenshot({ path: SS_PATH, fullPage: true });
            console.log('SCREENSHOT=' + SS_PATH);
            const editorReady = page.locator(editorReadySelectors.join(',')).first();
            const loginLike = page.locator(loginOrBlockSelectors.join(',')).first();
            
            const isEditorReady = await editorReady.isVisible().catch(() => false);
            const isLoginLike = await loginLike.isVisible().catch(() => false);
            
            console.log('DEBUG_IS_EDITOR_READY=', isEditorReady);
            console.log('DEBUG_IS_LOGIN_LIKE=', isLoginLike);
            
            if (!isEditorReady) {
              fs.writeFileSync('debug.html', await page.content());
            
              if (isLoginLike) {
                await page.screenshot({ path: 'debug-login.png', fullPage: true });
                throw new Error('Not logged in (login UI detected)');
              } else {
                await page.screenshot({ path: 'debug-not-ready.png', fullPage: true });
                throw new Error('Editor not ready (JS init failed / blocked / network)');
              }
            }



            // タイトル
            // タイトル（UI変更に強い探索）
            const titleCandidates = [
            // note現行で強い（最優先）
            '[contenteditable="true"][data-placeholder*="記事タイトル"]',
            '[contenteditable="true"][data-placeholder*="タイトル"]',
            '[contenteditable="true"][aria-placeholder*="記事タイトル"]',
            '[contenteditable="true"][aria-placeholder*="タイトル"]',
          
            // 念のため role/aria-label 系
            '[contenteditable="true"][role="textbox"][aria-label*="記事タイトル"]',
            '[contenteditable="true"][role="textbox"][aria-label*="タイトル"]',
          
            // 旧UI（残してOK）
            'textarea[placeholder*="タイトル"]',
            'textarea[aria-label*="タイトル"]',
            'input[placeholder*="タイトル"]',
            'input[aria-label*="タイトル"]',
          ];
            
            // SPAで描画が遅いことがあるので少し待つ
            await page.waitForLoadState('networkidle').catch(() => {});
            await page.waitForTimeout(500);
            
            let titleLocator = null;
            for (const sel of titleCandidates) {
              const loc = page.locator(sel).first();
              if (await loc.isVisible().catch(() => false)) { titleLocator = loc; break; }
            }

            if (!titleLocator) {
              // もう一回だけ待って再探索
              await page.waitForTimeout(1500);
              for (const sel of titleCandidates) {
                const loc = page.locator(sel).first();
                if (await loc.count()) { titleLocator = loc; break; }
              }
            }
            if (!titleLocator) {
              console.log('DEBUG_TITLE_NOT_FOUND_URL=' + page.url());
              fs.writeFileSync('debug.html', await page.content());
              throw new Error('Title input not found');
            }
            
            await titleLocator.waitFor({ state: 'visible', timeout: 180000 });
            
            // textarea/input なら fill、contenteditable ならキーボード入力
            const tagName = await titleLocator.evaluate(el => el.tagName.toLowerCase());
            if (tagName === 'textarea' || tagName === 'input') {
              await titleLocator.fill(TITLE);
            } else {
              await titleLocator.click({ force: true });
              await page.keyboard.press('Control+A');
              await page.keyboard.type(TITLE, { delay: 5 });
            }


            // 本文（contenteditable）
            // 本文（タイトルの次にある textbox を狙う）
            const textboxes = page.locator('[contenteditable="true"][role="textbox"]');
            await textboxes.first().waitFor({ state: 'visible' });
            const bodyBox = textboxes.nth(1); // 0:タイトル、1:本文 になっているケースが多い
            await bodyBox.waitFor({ state: 'visible', timeout: 180000 });


            // 既存内容を消してからHTML挿入
            await bodyBox.click();
            await page.keyboard.press('Control+A');
            await page.keyboard.press('Backspace');

            await insertHTML(page, bodyBox, rawBodyHtml);
            await page.waitForTimeout(200);

            if (!IS_PUBLIC) {
              const saveBtn = page.locator('button:has-text("下書き保存"), [aria-label*="下書き保存"]').first();
              await saveBtn.waitFor({ state: 'visible' });
              if (await saveBtn.isEnabled()) {
                await saveBtn.click();
                await page.locator('text=保存しました').waitFor({ timeout: 4000 }).catch(() => {});
              }
              await page.screenshot({ path: SS_PATH, fullPage: true });
              console.log('DRAFT_URL=' + page.url());
              console.log('SCREENSHOT=' + SS_PATH);
              process.exit(0);
            }


            const proceed = page.locator('button:has-text("公開に進む")').first();
            await proceed.waitFor({ state: 'visible' });
            for (let i = 0; i < 20; i++) {
              if (await proceed.isEnabled()) break;
              await page.waitForTimeout(100);
            }
            await proceed.click({ force: true });

            await Promise.race([
              page.waitForURL(/\/publish/i).catch(() => {}),
              page.locator('button:has-text("投稿する")').first().waitFor({ state: 'visible' }).catch(() => {})
            ]);

            // タグ
            const tags = (TAGS || '').split(/[\n,]/).map(s => s.trim()).filter(Boolean);
            if (tags.length) {
              let tagInput = page.locator('input[placeholder*="ハッシュタグ"]');
              if (!(await tagInput.count())) tagInput = page.locator('input[role="combobox"]').first();
              await tagInput.waitFor({ state: 'visible' });
              for (const t of tags) {
                await tagInput.click();
                await tagInput.fill(t);
                await page.keyboard.press('Enter');
                await page.waitForTimeout(120);
              }
            }

            const publishBtn = page.locator('button:has-text("投稿する")').first();
            await publishBtn.waitFor({ state: 'visible' });
            for (let i = 0; i < 20; i++) {
              if (await publishBtn.isEnabled()) break;
              await page.waitForTimeout(100);
            }
            await publishBtn.click({ force: true });

            await Promise.race([
              page.waitForURL(u => !/\/publish/i.test(typeof u === 'string' ? u : u.toString()), { timeout: 20000 }).catch(() => {}),
              page.locator('text=投稿しました').first().waitFor({ timeout: 8000 }).catch(() => {}),
              page.waitForTimeout(5000)
            ]);

            await page.screenshot({ path: SS_PATH, fullPage: true });
            const finalUrl = page.url();
            console.log('PUBLISHED_URL=' + finalUrl);
            console.log('SCREENSHOT=' + SS_PATH);
          }  {
            try { await context?.tracing?.stop({ path: 'trace.zip' }); } catch {}
            try { await page?.close(); } catch {}
            try { await context?.close(); } catch {}
            try { await browser?.close(); } catch {}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

          - name: Upload debug artifacts
            if: ${{ always() }}
            uses: actions/upload-artifact@v4
            with:
              name: note-debug-${{ github.run_id }}
              if-no-files-found: warn
              path: |
                post.log
                debug.html
                debug.png
                debug-login.png
                debug-not-ready.png
                trace.zip
                /tmp/note-screenshots/**


      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
